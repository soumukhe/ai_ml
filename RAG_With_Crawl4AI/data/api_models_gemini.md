[ Skip to content ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_aimodelsgemini>)
[ ![logo](https://ai.pydantic.dev/img/logo-white.svg) ](https://ai.pydantic.dev/api/models/gemini/..> "PydanticAI")
PydanticAI 
pydantic_ai.models.gemini 
Initializing search 
[ pydantic/pydantic-ai  ](https://ai.pydantic.dev/api/models/gemini/<https:/github.com/pydantic/pydantic-ai> "Go to repository")
[ ![logo](https://ai.pydantic.dev/img/logo-white.svg) ](https://ai.pydantic.dev/api/models/gemini/..> "PydanticAI") PydanticAI 
[ pydantic/pydantic-ai  ](https://ai.pydantic.dev/api/models/gemini/<https:/github.com/pydantic/pydantic-ai> "Go to repository")
  * [ Introduction  ](https://ai.pydantic.dev/api/models/gemini/..>)
  * [ Installation  ](https://ai.pydantic.dev/api/models/install/>)
  * [ Getting Help  ](https://ai.pydantic.dev/api/models/help/>)
  * [ Contributing  ](https://ai.pydantic.dev/api/models/contributing/>)
  * [ Troubleshooting  ](https://ai.pydantic.dev/api/models/troubleshooting/>)
  * Documentation  Documentation 
    * [ Agents  ](https://ai.pydantic.dev/api/models/agents/>)
    * [ Models  ](https://ai.pydantic.dev/api/models/models/>)
    * [ Dependencies  ](https://ai.pydantic.dev/api/models/dependencies/>)
    * [ Function Tools  ](https://ai.pydantic.dev/api/models/tools/>)
    * [ Results  ](https://ai.pydantic.dev/api/models/results/>)
    * [ Messages and chat history  ](https://ai.pydantic.dev/api/models/message-history/>)
    * [ Testing and Evals  ](https://ai.pydantic.dev/api/models/testing-evals/>)
    * [ Debugging and Monitoring  ](https://ai.pydantic.dev/api/models/logfire/>)
    * [ Multi-agent Applications  ](https://ai.pydantic.dev/api/models/multi-agent-applications/>)
  * [ Examples  ](https://ai.pydantic.dev/api/models/examples/>)
Examples 
    * [ Pydantic Model  ](https://ai.pydantic.dev/api/models/examples/pydantic-model/>)
    * [ Weather agent  ](https://ai.pydantic.dev/api/models/examples/weather-agent/>)
    * [ Bank support  ](https://ai.pydantic.dev/api/models/examples/bank-support/>)
    * [ SQL Generation  ](https://ai.pydantic.dev/api/models/examples/sql-gen/>)
    * [ Flight booking  ](https://ai.pydantic.dev/api/models/examples/flight-booking/>)
    * [ RAG  ](https://ai.pydantic.dev/api/models/examples/rag/>)
    * [ Stream markdown  ](https://ai.pydantic.dev/api/models/examples/stream-markdown/>)
    * [ Stream whales  ](https://ai.pydantic.dev/api/models/examples/stream-whales/>)
    * [ Chat App with FastAPI  ](https://ai.pydantic.dev/api/models/examples/chat-app/>)
  * API Reference  API Reference 
    * [ pydantic_ai.agent  ](https://ai.pydantic.dev/api/models/gemini/agent/>)
    * [ pydantic_ai.tools  ](https://ai.pydantic.dev/api/models/gemini/tools/>)
    * [ pydantic_ai.result  ](https://ai.pydantic.dev/api/models/gemini/result/>)
    * [ pydantic_ai.messages  ](https://ai.pydantic.dev/api/models/gemini/messages/>)
    * [ pydantic_ai.exceptions  ](https://ai.pydantic.dev/api/models/gemini/exceptions/>)
    * [ pydantic_ai.settings  ](https://ai.pydantic.dev/api/models/gemini/settings/>)
    * [ pydantic_ai.usage  ](https://ai.pydantic.dev/api/models/gemini/usage/>)
    * [ pydantic_ai.format_as_xml  ](https://ai.pydantic.dev/api/models/gemini/format_as_xml/>)
    * [ pydantic_ai.models  ](https://ai.pydantic.dev/api/models/gemini/<../base/>)
    * [ pydantic_ai.models.openai  ](https://ai.pydantic.dev/api/models/gemini/<../openai/>)
    * [ pydantic_ai.models.anthropic  ](https://ai.pydantic.dev/api/models/gemini/<../anthropic/>)
    * pydantic_ai.models.gemini  [ pydantic_ai.models.gemini  ](https://ai.pydantic.dev/api/models/gemini/<./>) Table of contents 
      * [ Setup  ](https://ai.pydantic.dev/api/models/gemini/<#setup>)
        * [ gemini  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini>)
        * [ GeminiModelName  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiModelName>)
        * [ GeminiModel  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiModel>)
          * [ __init__  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiModel.__init__>)
        * [ AuthProtocol  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.AuthProtocol>)
        * [ ApiKeyAuth  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.ApiKeyAuth>)
        * [ GeminiAgentModel  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiAgentModel>)
        * [ GeminiStreamTextResponse  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiStreamTextResponse>)
        * [ GeminiStreamStructuredResponse  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiStreamStructuredResponse>)
          * [ get  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiStreamStructuredResponse.get>)
    * [ pydantic_ai.models.vertexai  ](https://ai.pydantic.dev/api/models/gemini/<../vertexai/>)
    * [ pydantic_ai.models.groq  ](https://ai.pydantic.dev/api/models/gemini/<../groq/>)
    * [ pydantic_ai.models.mistral  ](https://ai.pydantic.dev/api/models/gemini/<../mistral/>)
    * [ pydantic_ai.models.ollama  ](https://ai.pydantic.dev/api/models/gemini/<../ollama/>)
    * [ pydantic_ai.models.test  ](https://ai.pydantic.dev/api/models/gemini/<../test/>)
    * [ pydantic_ai.models.function  ](https://ai.pydantic.dev/api/models/gemini/<../function/>)


Table of contents 
  * [ Setup  ](https://ai.pydantic.dev/api/models/gemini/<#setup>)
    * [ gemini  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini>)
    * [ GeminiModelName  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiModelName>)
    * [ GeminiModel  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiModel>)
      * [ __init__  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiModel.__init__>)
    * [ AuthProtocol  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.AuthProtocol>)
    * [ ApiKeyAuth  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.ApiKeyAuth>)
    * [ GeminiAgentModel  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiAgentModel>)
    * [ GeminiStreamTextResponse  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiStreamTextResponse>)
    * [ GeminiStreamStructuredResponse  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiStreamStructuredResponse> "GeminiStreamStructuredResponse")
      * [ get  ](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiStreamStructuredResponse.get>)


  1. [ Introduction  ](https://ai.pydantic.dev/api/models/gemini/..>)
  2. [ API Reference  ](https://ai.pydantic.dev/api/models/gemini/agent/>)


# `pydantic_ai.models.gemini`
Custom interface to the `generativelanguage.googleapis.com` API using [HTTPX](https://ai.pydantic.dev/api/models/gemini/<https:/www.python-httpx.org/>) and [Pydantic](https://ai.pydantic.dev/api/models/gemini/<https:/docs.pydantic.dev/latest/>).
The Google SDK for interacting with the `generativelanguage.googleapis.com` API `google-generativeai`[](https://ai.pydantic.dev/api/models/gemini/<https:/ai.google.dev/gemini-api/docs/quickstart?lang=python>) reads like it was written by a Java developer who thought they knew everything about OOP, spent 30 minutes trying to learn Python, gave up and decided to build the library to prove how horrible Python is. It also doesn't use httpx for HTTP requests, and tries to implement tool calling itself, but doesn't use Pydantic or equivalent for validation.
We therefore implement support for the API directly.
Despite these shortcomings, the Gemini model is actually quite powerful and very fast.
## Setup
For details on how to set up authentication with this model, see [model configuration for Gemini](https://ai.pydantic.dev/api/models/models/#gemini>).
###  GeminiModelName `module-attribute`
```
GeminiModelName = Literal[](https://ai.pydantic.dev/api/models/gemini/<https:/docs.python.org/3/library/typing.html#typing.Literal> "typing.Literal")[
  "gemini-1.5-flash",
  "gemini-1.5-flash-8b",
  "gemini-1.5-pro",
  "gemini-1.0-pro",
  "gemini-2.0-flash-exp",
]

```

Named Gemini models.
See [the Gemini API docs](https://ai.pydantic.dev/api/models/gemini/<https:/ai.google.dev/gemini-api/docs/models/gemini#model-variations>) for a full list.
###  GeminiModel `dataclass`
Bases: `Model[](https://ai.pydantic.dev/api/models/gemini/<../base/#pydantic_ai.models.Model> "pydantic_ai.models.Model")`
A model that uses Gemini via `generativelanguage.googleapis.com` API.
This is implemented from scratch rather than using a dedicated SDK, good API documentation is available [here](https://ai.pydantic.dev/api/models/gemini/<https:/ai.google.dev/api>).
Apart from `__init__`, all methods are private or match those of the base class.
Source code in `pydantic_ai_slim/pydantic_ai/models/gemini.py`
```
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
```
| ```
@dataclass(init=False)
class GeminiModel(Model):
"""A model that uses Gemini via `generativelanguage.googleapis.com` API.
  This is implemented from scratch rather than using a dedicated SDK, good API documentation is
  available [here](https://ai.google.dev/api).
  Apart from `__init__`, all methods are private or match those of the base class.
  """
  model_name: GeminiModelName
  auth: AuthProtocol
  http_client: AsyncHTTPClient
  url: str
  def __init__(
    self,
    model_name: GeminiModelName,
    *,
    api_key: str | None = None,
    http_client: AsyncHTTPClient | None = None,
    url_template: str = 'https://generativelanguage.googleapis.com/v1beta/models/{model}:',
  ):
"""Initialize a Gemini model.
    Args:
      model_name: The name of the model to use.
      api_key: The API key to use for authentication, if not provided, the `GEMINI_API_KEY` environment variable
        will be used if available.
      http_client: An existing `httpx.AsyncClient` to use for making HTTP requests.
      url_template: The URL template to use for making requests, you shouldn't need to change this,
        docs [here](https://ai.google.dev/gemini-api/docs/quickstart?lang=rest#make-first-request),
        `model` is substituted with the model name, and `function` is added to the end of the URL.
    """
    self.model_name = model_name
    if api_key is None:
      if env_api_key := os.getenv('GEMINI_API_KEY'):
        api_key = env_api_key
      else:
        raise exceptions.UserError('API key must be provided or set in the GEMINI_API_KEY environment variable')
    self.auth = ApiKeyAuth(api_key)
    self.http_client = http_client or cached_async_http_client()
    self.url = url_template.format(model=model_name)
  async def agent_model(
    self,
    *,
    function_tools: list[ToolDefinition],
    allow_text_result: bool,
    result_tools: list[ToolDefinition],
  ) -> GeminiAgentModel:
    return GeminiAgentModel(
      http_client=self.http_client,
      model_name=self.model_name,
      auth=self.auth,
      url=self.url,
      function_tools=function_tools,
      allow_text_result=allow_text_result,
      result_tools=result_tools,
    )
  def name(self) -> str:
    return f'google-gla:{self.model_name}'

```
  
---|---  
####  __init__
```
__init__(
  model_name: GeminiModelName[](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiModelName> "pydantic_ai.models.gemini.GeminiModelName"),
  *,
  api_key: str[](https://ai.pydantic.dev/api/models/gemini/<https:/docs.python.org/3/library/stdtypes.html#str>) | None = None,
  http_client: AsyncClient | None = None,
  url_template: str[](https://ai.pydantic.dev/api/models/gemini/<https:/docs.python.org/3/library/stdtypes.html#str>) = "https://generativelanguage.googleapis.com/v1beta/models/{model}:"
)

```

Initialize a Gemini model.
Parameters:
Name | Type | Description | Default  
---|---|---|---  
`model_name` |  `GeminiModelName[](https://ai.pydantic.dev/api/models/gemini/<#pydantic_ai.models.gemini.GeminiModelName> "pydantic_ai.models.gemini.GeminiModelName")` |  The name of the model to use. |  _required_  
`api_key` |  `str[](https://ai.pydantic.dev/api/models/gemini/<https:/docs.python.org/3/library/stdtypes.html#str>) | None` |  The API key to use for authentication, if not provided, the `GEMINI_API_KEY` environment variable will be used if available. |  `None`  
`http_client` |  `AsyncClient | None` |  An existing `httpx.AsyncClient` to use for making HTTP requests. |  `None`  
`url_template` |  `str[](https://ai.pydantic.dev/api/models/gemini/<https:/docs.python.org/3/library/stdtypes.html#str>)` |  The URL template to use for making requests, you shouldn't need to change this, docs [here](https://ai.pydantic.dev/api/models/gemini/<https:/ai.google.dev/gemini-api/docs/quickstart?lang=rest#make-first-request>), `model` is substituted with the model name, and `function` is added to the end of the URL. |  `'https://generativelanguage.googleapis.com/v1beta/models/{model}:'`  
Source code in `pydantic_ai_slim/pydantic_ai/models/gemini.py`
```
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
```
| ```
def __init__(
  self,
  model_name: GeminiModelName,
  *,
  api_key: str | None = None,
  http_client: AsyncHTTPClient | None = None,
  url_template: str = 'https://generativelanguage.googleapis.com/v1beta/models/{model}:',
):
"""Initialize a Gemini model.
  Args:
    model_name: The name of the model to use.
    api_key: The API key to use for authentication, if not provided, the `GEMINI_API_KEY` environment variable
      will be used if available.
    http_client: An existing `httpx.AsyncClient` to use for making HTTP requests.
    url_template: The URL template to use for making requests, you shouldn't need to change this,
      docs [here](https://ai.google.dev/gemini-api/docs/quickstart?lang=rest#make-first-request),
      `model` is substituted with the model name, and `function` is added to the end of the URL.
  """
  self.model_name = model_name
  if api_key is None:
    if env_api_key := os.getenv('GEMINI_API_KEY'):
      api_key = env_api_key
    else:
      raise exceptions.UserError('API key must be provided or set in the GEMINI_API_KEY environment variable')
  self.auth = ApiKeyAuth(api_key)
  self.http_client = http_client or cached_async_http_client()
  self.url = url_template.format(model=model_name)

```
  
---|---  
###  AuthProtocol
Bases: `Protocol[](https://ai.pydantic.dev/api/models/gemini/<https:/docs.python.org/3/library/typing.html#typing.Protocol> "typing.Protocol")`
Abstract definition for Gemini authentication.
Source code in `pydantic_ai_slim/pydantic_ai/models/gemini.py`
```
117
118
119
120
```
| ```
class AuthProtocol(Protocol):
"""Abstract definition for Gemini authentication."""
  async def headers(self) -> dict[str, str]: ...

```
  
---|---  
###  ApiKeyAuth `dataclass`
Authentication using an API key for the `X-Goog-Api-Key` header.
Source code in `pydantic_ai_slim/pydantic_ai/models/gemini.py`
```
123
124
125
126
127
128
129
130
131
```
| ```
@dataclass
class ApiKeyAuth:
"""Authentication using an API key for the `X-Goog-Api-Key` header."""
  api_key: str
  async def headers(self) -> dict[str, str]:
    # https://cloud.google.com/docs/authentication/api-keys-use#using-with-rest
    return {'X-Goog-Api-Key': self.api_key}

```
  
---|---  
###  GeminiAgentModel `dataclass`
Bases: `AgentModel[](https://ai.pydantic.dev/api/models/gemini/<../base/#pydantic_ai.models.AgentModel> "pydantic_ai.models.AgentModel")`
Implementation of `AgentModel` for Gemini models.
Source code in `pydantic_ai_slim/pydantic_ai/models/gemini.py`
```
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
```
| ```
@dataclass(init=False)
class GeminiAgentModel(AgentModel):
"""Implementation of `AgentModel` for Gemini models."""
  http_client: AsyncHTTPClient
  model_name: GeminiModelName
  auth: AuthProtocol
  tools: _GeminiTools | None
  tool_config: _GeminiToolConfig | None
  url: str
  def __init__(
    self,
    http_client: AsyncHTTPClient,
    model_name: GeminiModelName,
    auth: AuthProtocol,
    url: str,
    function_tools: list[ToolDefinition],
    allow_text_result: bool,
    result_tools: list[ToolDefinition],
  ):
    check_allow_model_requests()
    tools = [_function_from_abstract_tool(t) for t in function_tools]
    if result_tools:
      tools += [_function_from_abstract_tool(t) for t in result_tools]
    if allow_text_result:
      tool_config = None
    else:
      tool_config = _tool_config([t['name'] for t in tools])
    self.http_client = http_client
    self.model_name = model_name
    self.auth = auth
    self.tools = _GeminiTools(function_declarations=tools) if tools else None
    self.tool_config = tool_config
    self.url = url
  async def request(
    self, messages: list[ModelMessage], model_settings: ModelSettings | None
  ) -> tuple[ModelResponse, result.Usage]:
    async with self._make_request(messages, False, model_settings) as http_response:
      response = _gemini_response_ta.validate_json(await http_response.aread())
    return self._process_response(response), _metadata_as_usage(response)
  @asynccontextmanager
  async def request_stream(
    self, messages: list[ModelMessage], model_settings: ModelSettings | None
  ) -> AsyncIterator[EitherStreamedResponse]:
    async with self._make_request(messages, True, model_settings) as http_response:
      yield await self._process_streamed_response(http_response)
  @asynccontextmanager
  async def _make_request(
    self, messages: list[ModelMessage], streamed: bool, model_settings: ModelSettings | None
  ) -> AsyncIterator[HTTPResponse]:
    sys_prompt_parts, contents = self._message_to_gemini_content(messages)
    request_data = _GeminiRequest(contents=contents)
    if sys_prompt_parts:
      request_data['system_instruction'] = _GeminiTextContent(role='user', parts=sys_prompt_parts)
    if self.tools is not None:
      request_data['tools'] = self.tools
    if self.tool_config is not None:
      request_data['tool_config'] = self.tool_config
    generation_config: _GeminiGenerationConfig = {}
    if model_settings:
      if (max_tokens := model_settings.get('max_tokens')) is not None:
        generation_config['max_output_tokens'] = max_tokens
      if (temperature := model_settings.get('temperature')) is not None:
        generation_config['temperature'] = temperature
      if (top_p := model_settings.get('top_p')) is not None:
        generation_config['top_p'] = top_p
    if generation_config:
      request_data['generation_config'] = generation_config
    url = self.url + ('streamGenerateContent' if streamed else 'generateContent')
    headers = {
      'Content-Type': 'application/json',
      'User-Agent': get_user_agent(),
      **await self.auth.headers(),
    }
    request_json = _gemini_request_ta.dump_json(request_data, by_alias=True)
    async with self.http_client.stream(
      'POST',
      url,
      content=request_json,
      headers=headers,
      timeout=(model_settings or {}).get('timeout', USE_CLIENT_DEFAULT),
    ) as r:
      if r.status_code != 200:
        await r.aread()
        raise exceptions.UnexpectedModelBehavior(f'Unexpected response from gemini {r.status_code}', r.text)
      yield r
  @staticmethod
  def _process_response(response: _GeminiResponse) -> ModelResponse:
    if len(response['candidates']) != 1:
      raise UnexpectedModelBehavior('Expected exactly one candidate in Gemini response')
    parts = response['candidates'][0]['content']['parts']
    return _process_response_from_parts(parts)
  @staticmethod
  async def _process_streamed_response(http_response: HTTPResponse) -> EitherStreamedResponse:
"""Process a streamed response, and prepare a streaming response to return."""
    aiter_bytes = http_response.aiter_bytes()
    start_response: _GeminiResponse | None = None
    content = bytearray()
    async for chunk in aiter_bytes:
      content.extend(chunk)
      responses = _gemini_streamed_response_ta.validate_json(
        content,
        experimental_allow_partial='trailing-strings',
      )
      if responses:
        last = responses[-1]
        if last['candidates'] and last['candidates'][0]['content']['parts']:
          start_response = last
          break
    if start_response is None:
      raise UnexpectedModelBehavior('Streamed response ended without content or tool calls')
    # TODO: Update this once we rework stream responses to be more flexible
    if _extract_response_parts(start_response).is_left():
      return GeminiStreamStructuredResponse(_content=content, _stream=aiter_bytes)
    else:
      return GeminiStreamTextResponse(_json_content=content, _stream=aiter_bytes)
  @classmethod
  def _message_to_gemini_content(
    cls, messages: list[ModelMessage]
  ) -> tuple[list[_GeminiTextPart], list[_GeminiContent]]:
    sys_prompt_parts: list[_GeminiTextPart] = []
    contents: list[_GeminiContent] = []
    for m in messages:
      if isinstance(m, ModelRequest):
        message_parts: list[_GeminiPartUnion] = []
        for part in m.parts:
          if isinstance(part, SystemPromptPart):
            sys_prompt_parts.append(_GeminiTextPart(text=part.content))
          elif isinstance(part, UserPromptPart):
            message_parts.append(_GeminiTextPart(text=part.content))
          elif isinstance(part, ToolReturnPart):
            message_parts.append(_response_part_from_response(part.tool_name, part.model_response_object()))
          elif isinstance(part, RetryPromptPart):
            if part.tool_name is None:
              message_parts.append(_GeminiTextPart(text=part.model_response()))
            else:
              response = {'call_error': part.model_response()}
              message_parts.append(_response_part_from_response(part.tool_name, response))
          else:
            assert_never(part)
        if message_parts:
          contents.append(_GeminiContent(role='user', parts=message_parts))
      elif isinstance(m, ModelResponse):
        contents.append(_content_model_response(m))
      else:
        assert_never(m)
    return sys_prompt_parts, contents

```
  
---|---  
###  GeminiStreamTextResponse `dataclass`
Bases: `StreamTextResponse[](https://ai.pydantic.dev/api/models/gemini/<../base/#pydantic_ai.models.StreamTextResponse> "pydantic_ai.models.StreamTextResponse")`
Implementation of `StreamTextResponse` for the Gemini model.
Source code in `pydantic_ai_slim/pydantic_ai/models/gemini.py`
```
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
```
| ```
@dataclass
class GeminiStreamTextResponse(StreamTextResponse):
"""Implementation of `StreamTextResponse` for the Gemini model."""
  _json_content: bytearray
  _stream: AsyncIterator[bytes]
  _position: int = 0
  _timestamp: datetime = field(default_factory=_utils.now_utc, init=False)
  _usage: result.Usage = field(default_factory=result.Usage, init=False)
  async def __anext__(self) -> None:
    chunk = await self._stream.__anext__()
    self._json_content.extend(chunk)
  def get(self, *, final: bool = False) -> Iterable[str]:
    if final:
      all_items = pydantic_core.from_json(self._json_content)
      new_items = all_items[self._position :]
      self._position = len(all_items)
      new_responses = _gemini_streamed_response_ta.validate_python(new_items)
    else:
      all_items = pydantic_core.from_json(self._json_content, allow_partial=True)
      new_items = all_items[self._position : -1]
      self._position = len(all_items) - 1
      new_responses = _gemini_streamed_response_ta.validate_python(
        new_items, experimental_allow_partial='trailing-strings'
      )
    for r in new_responses:
      self._usage += _metadata_as_usage(r)
      parts = r['candidates'][0]['content']['parts']
      if _all_text_parts(parts):
        for part in parts:
          yield part['text']
      else:
        raise UnexpectedModelBehavior(
          'Streamed response with unexpected content, expected all parts to be text'
        )
  def usage(self) -> result.Usage:
    return self._usage
  def timestamp(self) -> datetime:
    return self._timestamp

```
  
---|---  
###  GeminiStreamStructuredResponse `dataclass`
Bases: `StreamStructuredResponse[](https://ai.pydantic.dev/api/models/gemini/<../base/#pydantic_ai.models.StreamStructuredResponse> "pydantic_ai.models.StreamStructuredResponse")`
Implementation of `StreamStructuredResponse` for the Gemini model.
Source code in `pydantic_ai_slim/pydantic_ai/models/gemini.py`
```
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
```
| ```
@dataclass
class GeminiStreamStructuredResponse(StreamStructuredResponse):
"""Implementation of `StreamStructuredResponse` for the Gemini model."""
  _content: bytearray
  _stream: AsyncIterator[bytes]
  _timestamp: datetime = field(default_factory=_utils.now_utc, init=False)
  _usage: result.Usage = field(default_factory=result.Usage, init=False)
  async def __anext__(self) -> None:
    chunk = await self._stream.__anext__()
    self._content.extend(chunk)
  def get(self, *, final: bool = False) -> ModelResponse:
"""Get the `ModelResponse` at this point.
    NOTE: It's not clear how the stream of responses should be combined because Gemini seems to always
    reply with a single response, when returning a structured data.
    I'm therefore assuming that each part contains a complete tool call, and not trying to combine data from
    separate parts.
    """
    responses = _gemini_streamed_response_ta.validate_json(
      self._content,
      experimental_allow_partial='off' if final else 'trailing-strings',
    )
    combined_parts: list[_GeminiPartUnion] = []
    self._usage = result.Usage()
    for r in responses:
      self._usage += _metadata_as_usage(r)
      candidate = r['candidates'][0]
      combined_parts.extend(candidate['content']['parts'])
    return _process_response_from_parts(combined_parts, timestamp=self._timestamp)
  def usage(self) -> result.Usage:
    return self._usage
  def timestamp(self) -> datetime:
    return self._timestamp

```
  
---|---  
####  get
```
get(*, final: bool[](https://ai.pydantic.dev/api/models/gemini/<https:/docs.python.org/3/library/functions.html#bool>) = False) -> ModelResponse[](https://ai.pydantic.dev/api/models/gemini/messages/#pydantic_ai.messages.ModelResponse> "pydantic_ai.messages.ModelResponse")

```

Get the `ModelResponse` at this point.
NOTE: It's not clear how the stream of responses should be combined because Gemini seems to always reply with a single response, when returning a structured data.
I'm therefore assuming that each part contains a complete tool call, and not trying to combine data from separate parts.
Source code in `pydantic_ai_slim/pydantic_ai/models/gemini.py`
```
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
```
| ```
def get(self, *, final: bool = False) -> ModelResponse:
"""Get the `ModelResponse` at this point.
  NOTE: It's not clear how the stream of responses should be combined because Gemini seems to always
  reply with a single response, when returning a structured data.
  I'm therefore assuming that each part contains a complete tool call, and not trying to combine data from
  separate parts.
  """
  responses = _gemini_streamed_response_ta.validate_json(
    self._content,
    experimental_allow_partial='off' if final else 'trailing-strings',
  )
  combined_parts: list[_GeminiPartUnion] = []
  self._usage = result.Usage()
  for r in responses:
    self._usage += _metadata_as_usage(r)
    candidate = r['candidates'][0]
    combined_parts.extend(candidate['content']['parts'])
  return _process_response_from_parts(combined_parts, timestamp=self._timestamp)

```
  
---|---  
© Pydantic Services Inc. 2024 to present 
